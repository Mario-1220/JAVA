# 学成在线项目心得

每次重新启动虚拟机时：

1.打开vm_vare

2.执行systemctl start docker 启动docker

3.运行 sh /data/soft/restart.sh 执行脚本启动docker中的服务



接口类型：

VO 用于在前端和接口层传递数据

DTO 用于接口层向业务层之间传输数据

PO 用于业务层与持久层之间传输数据

![image-20230705100600224](C:\Users\Mario\AppData\Roaming\Typora\typora-user-images\image-20230705100600224.png)



CORS全称是cross origin resource share表示跨域资源共享，从一个地址请求另一个地址，如果协议、主机、端口三者全部一致则不属于跨域，否则有一个不一致就是跨域请求。

解决跨域的方法：

![image-20230705155000666](C:\Users\Mario\AppData\Roaming\Typora\typora-user-images\image-20230705155000666.png)



传入的是json数据的话 如果要将其转为对象则需要加@RequestBody注解



编写流程

1.定义接口

2.编写mapper

3.编写service



写数据库时要进行事务控制



## 关于树形结构的节点表 

查询时需要用到同一张表的内联查询(例如CourseCategory课程分类表的查询)

select * from course_category one inner join course_category two on two.parentid=one.id 

也可以用递归查询

with recursive t1 as(

​    select * from course_category where id='1'

​    union all

​    select t2.* from course_category t2 inner join t1 on t1.id=t2.parentid

)

select * from t1



在mapper文件中编写sql语句时需要注意的点

1. mapper接口中的方法名与相对应的.xml文件中的id相对应
2. resulttype一般用于返回结果与数据库字段正好对应 resultmap则用于手动对数据库中的字段与po类中的属性相对应

同时要注意resultmap处理查询到的数据和dto类中的属性进行映射时 除了主键使用<id column="" property="">外，普通属性均用<result column="" property="">  

映射子节点时 一对多映射要使用<collection property="" ofType="">ofType指的是list中的对象类型。



在拷贝类与类之间的信息时 如果一个类A包含另一个类B

则可以使用BeanUtils.*copyProperties*(A, B);将A中的信息拷贝到B中 不用再单独进行set



断点续传：

基于分块上传的模式实现断点续传的需求，当文件上传一部分断网后前边已经上传过的文件不再上传。

1)前端对文件分块

2)前端使用多线程一块一块上传，上传给服务端发一个消息校验该分块是否上传，如果已上传则不再上传。

3)等所有分块上传完毕，服务端合并所有分块，校验文件的完整性。

因为分块全部上传到了服务器，服务器将所有分块顺序进行合序，就是写每个分块文件内容按顺序依次写入一个文件中。使用字节流去读写文件。

4)前端给服务传了一个md5值，服务端合并文件后计算合并文件的md5是否和前端传的一样，如果一样则说明文件完整，如果不一样说明可能由于网络丢包导致文件不完整，这时上传失败需要重新上传。



远程调用服务时feignclient

编写接口并添加注解@FeignClient(value="",fallbackFactory="") 同时编写回调方法集成FallbackFactory并重写creat方法

同时要在启动类上面添加注解@EnableFeignClients(basePackages={""})



## Spring事务

非事务性方法调用事务性方法时 需要通过注入自身的方式来调用事务方法才能开启事务，否则事务无法回滚。

什么情况下事务会失效：

1. 在方法中捕获异常没有抛出

2. 非事务方法调用事务方法

3. 事务方法内部调用事务方法

4. @Transactional标记的方法不是public

5. 抛出的异常与rollbackFor指定的异常不匹配， rollbackFor指定的异常为RuntimeException

6. 数据库表不支持事务 比如MYSQL的MyISAM

7. Spring的传播行为导致事务失效

   PROPAGATION_REQUIRED -- 支持当前事务，如果没有事务，就新建一个事务。

   PROPAGATION_SUPPORTS -- 支持当前事务，如果没有事务，就以非事务方式执行。

   PROPAGATION_MANDATORY -- 支持当前事务，如果当前没有事务，就抛出异常。

   PROPAGATION_REQUIRES_NEW -- 新建事务，如果当前存在事务，就把当前事务挂起。

   PROPAGATION_NOT_SUPPORTED -- 以非事务方式执行，如果当前存在事务，就把当前事务挂起。

   PROPAGATION_NEVER -- 以非事务方式执行，如果当前存在事务，则抛出异常。

   PROPAGATION_NESTED -- 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则与PROPAGATION_REQUIRED类似的操作。

## naco

导入依赖：

<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>

config用于配置文件相关配置 discovery用于服务注册相关配置

在bootstrap.yaml中配置相关信息：

spring:
  cloud:
    nacos:
      server-addr: 192.168.101.65:8848
      discovery:
        namespace: dev
        group: xuecheng-plus-project

当微服务依赖另一个服务的配置文件时 可以使用extension-configs来进行拉取

当微服务拉取全局配置信息时 则使用shared-configs

读取naco中的相关配置信息时 在Config文件中 一般先加@Configuration注解 然后使用@Value取值，层级递进以.区分，比如@Value("${spring.cloud.nacos.server-addr}") 然后使用一个函数返回值得到需要的东西并通过@Bean注入到Bean工厂中。

## Gateway网关

所有访问微服务的请求都要经过网关，在网关进行用户身份的认证将很多非法的请求拦截到微服务以外，即网关认证。

下边需要明确网关的职责：

1、网站白名单维护

针对不用认证的URL全部放行。

2、校验jwt的合法性。

除了白名单剩下的就是需要认证的请求，网关需要验证jwt的合法性，jwt合法则说明用户身份合法，否则说明身份不合法则拒绝继续访问。

## Spring Security

重写了DaoAuthenticationProvider的校验密码的方法，因为学成在线统一了认证入口，有一些认证方式并不需要校验密码。

1、统一认证入口:账号密码认证、微信扫码认证、手机验证码认证。

2、统一认证请求参数 AuthParamsDto

**Spring Security工作流程**

![image-20230727141933921](C:\Users\Mario\AppData\Roaming\Typora\typora-user-images\image-20230727141933921.png)

**用户认证流程：**

![image-20230727141959974](C:\Users\Mario\AppData\Roaming\Typora\typora-user-images\image-20230727141959974.png)



Spring Security判断用户的访问权限

loadUserByUsername中生成令牌的时候首先通过数据库查询用户的权限，然后将其权限放入userdetails中，并且在controller层中使用@PreAuthorize("hasAuthority(' ')")注解进行判断。
